ClusterIP, NodePort, LoadBalancer, and Ingress are distinct mechanisms in Kubernetes
for managing network access to services, each serving different purposes and use cases.

---->ClusterIP learn with KUBE-PROXY
It is the default service type in Kubernetes, exposing a service on a cluster-internal IP address,
making it accessible only within the cluster.
 ** It is ideal for internal communication between services,
    such as between front-end and back-end components, and is commonly used for debugging or internal dashboards.
 ** It does not allow external access, though the Kubernetes proxy(KUBE-PROXY) can be used for temporary external access
    during development.

    # clusterip-service.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-clusterip
    spec:
      type: ClusterIP  # Default, can be omitted
      selector:
        app: my-app
      ports:
      - port: 80        # Service port(DEFAULT HTTP PORT)/so no need to mention in the port with the cluster calls
        targetPort: 8080 # Pod port (this is where the application inside the container actually runs)
        protocol: TCP

----->KUBE-PROXY
The Kubernetes proxy, commonly referred to as Kube-Proxy,
is a critical component responsible for maintaining network rules on each node within a Kubernetes cluster.
(MAINTAINING THE RULES WITHIN KUBERNETES CLUSTER)
It acts as a network proxy and load balancer,
ensuring that traffic directed to Kubernetes Services is properly routed to the appropriate backend Pods,
even as the cluster dynamically changes.

----->NodePort
It is an extention of ClusterIP by exposing the service on a static port (30000–32767)
on each node's IP address, enabling external access.
 ** This method allows traffic to reach the service via any node's IP and the specified NodePort,
    but it is generally not recommended for production due to security risks,
    the need to manage static ports, and the potential for node IP changes requiring DNS updates.
 ** It is best suited for testing or temporary exposure of services.

     # nodeport-service.yaml
     apiVersion: v1
     kind: Service
     metadata:
       name: my-app-nodeport
     spec:
       type: NodePort
       selector:
         app: my-app
       ports:
       - port: 80        # Service port
         targetPort: 8080 # Pod port
         nodePort: 30007  # External port (30000-32767, optional)
         protocol: TCP

----->LoadBalancer
is designed for production environments on cloud platforms, automatically provisioning
a cloud provider’s load balancer (e.g., AWS ELB, GCP Load Balancer) to expose the service externally.
 ** It creates a stable external IP address that routes traffic to the service, handling load distribution across nodes.
 ** However, it can be costly, as each service typically requires its own load balancer,
    leading to potential cost inefficiencies when managing multiple services.

    In Kubernetes, load balancing is automatic when you put a Service in front of multiple Pods.
    but in cloud system we will
    # loadbalancer-service.yaml
    apiVersion: v1
    kind: Service
    metadata:
      name: my-app-loadbalancer
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-type: "nlb" # AWS specific
    spec:
      type: LoadBalancer #####
      selector:
        app: my-app
      ports:
      - port: 80
        targetPort: 8080
        protocol: TCP
      externalTrafficPolicy: Local

----->Ingress
is not a service type but an API object that acts as a smart router,
managing external HTTP/HTTPS access to multiple services within the cluster.
 ** It enables advanced routing based on hostnames or paths,
    allowing a single external IP to route traffic to different backend services.
 ** Ingress supports features like SSL termination(IMPORTANT), URL rewriting, and load balancing,
    making it highly efficient for complex applications with multiple services.
 ** It is typically used in production to reduce the number of load balancers
    needed and to provide flexible, scalable routing.

----->SSL Termination
is the process of decrypting encrypted traffic (HTTPS) at a network endpoint, such as a load balancer,
reverse proxy, or dedicated SSL termination device, before forwarding the unencrypted data to backend servers.
** This offloads the computationally intensive task of SSL/TLS decryption from backend servers,
   improving application performance, reducing server CPU usage, and allowing servers to focus on processing application logic.

In summary,
ClusterIP is for internal communication,
NodePort is a basic method for external access suitable for testing,
LoadBalancer is a cloud-native solution for direct external exposure,
and Ingress is the preferred choice for advanced, scalable routing in production environments.